<!DOCTYPE html><html lang="en"><head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Transparant Image</title>
  <style>
  	#bg-video {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    z-index: -1;
}
  	@font-face {
  font-family: 'BebasNeue';
  src: url('./BebasNeue-Regular.ttf') format('truetype');
  font-weight: normal;
  font-style: normal;
}

.footer {
  margin-top: 20px;
  font-size: 12px;
  color: #9aa9c9;
  font-family: 'BebasNeue', sans-serif;
}
  @font-face {
  font-family: 'Sequel100Black';
  src: url('./Sequel100Black-76.ttf') format('truetype');
  font-weight: normal;
  font-style: normal;
}

h1 {
  font-weight: 800;
  margin-bottom: 20px;
  font-family: 'Sequel100Black', sans-serif;
  font-size: 1.5rem; /* perkecil dari default */
  line-height: 1.2; /* rapatin jarak atas-bawah */
}
:root {
      --bg: #000;
      --fg: #fff;
      --blue: #2f7df4;
      --gray: #777;
    }
    body { margin:0; background:var(--bg); color:var(--fg); font-family:sans-serif; display:flex; justify-content:center; align-items:center; height:100vh; }
    .app { width:min(400px,90vw); text-align:center; }
    h1 { font-weight:800; margin-bottom:20px; }
    label { font-weight:600; }
    input[type="file"]{ width:100%; padding:10px; border:1px dashed rgba(255,255,255,.3); border-radius:10px; background:rgba(255,255,255,.05); color:var(--fg); }
    .row { margin:15px 0; display:flex; flex-direction:column; align-items:center; }
    .slider{ -webkit-appearance:none; appearance:none; width:100%; height:10px; border-radius:999px; background:linear-gradient(90deg,var(--blue) 50%,var(--gray) 50%); outline:none; }
    .slider::-webkit-slider-thumb{ -webkit-appearance:none; appearance:none; width:20px; height:20px; border-radius:50%; background:#fff; border:2px solid rgba(0,0,0,.2); cursor:pointer; }
    .slider::-moz-range-thumb{ width:20px; height:20px; border-radius:50%; background:#fff; border:2px solid rgba(0,0,0,.2); cursor:pointer; }
    .percent-control{ display:flex; align-items:center; gap:4px; margin-bottom:8px; }
    .percent-control input[type="number"] {
  width:50px;
  text-align:center; /* angka rata tengah */
  padding:4px;
  -moz-appearance: textfield;
}

.percent-control input[type="number"]::-webkit-inner-spin-button,
.percent-control input[type="number"]::-webkit-outer-spin-button {
  margin: 0;
}
    button{ padding:10px 20px; border-radius:8px; border:0; font-weight:700; color:var(--fg); background:var(--blue); cursor:pointer; }
    .msg-stack{ min-height:24px; margin-top:8px; transition:opacity 1s ease; }
    .footer{ margin-top:20px; font-size:12px; color:#ffffff; }
    .progress-text{ color:var(--blue); font-weight:600; margin-top:8px; }
    .hidden{ display:none; }
    .video-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.4); /* 80% gelap */
  z-index: 0;
}

.app {
  position: relative;
  z-index: 1;
}
  </style>
</head>
<script>
  window.addEventListener('DOMContentLoaded', () => {
  const music = document.getElementById('bg-music');
  music.muted = true;
  music.play().catch(err => console.log('Autoplay blocked:', err));

  // Coba unmute setelah sedikit delay
  setTimeout(() => {
    music.muted = false;
  }, 500); // 0.5 detik
});
</script>
<body>
	<video autoplay muted loop playsinline id="bg-video">
  <source src="background.mp4" type="video/mp4">
</video>
<audio id="bg-music" src="music.mp3" autoplay loop></audio>
<div class="video-overlay"></div>
  <div class="app">
    <h1>Transparant Image</h1><div class="row">
  <input id="file" type="file" multiple accept="image/*,.zip" />
  <div class="msg-stack" id="uploadMsg"></div>
</div>

<div class="row">
  <div class="percent-control">
    <label for="val">Adjust Transparent</label>
    <input type="number" id="val" value="50" min="0" max="100">%
  </div>
  <input id="range" class="slider" type="range" min="0" max="100" step="1" value="50" />
</div>

<div class="row">
  <button id="start">START</button>
  <div class="msg-stack" id="processMsg"></div>
  <div class="progress-text hidden" id="processProgress">Processing... 0%</div>
</div>

<div class="footer">- TwentySeven -</div>

<canvas id="canvas" hidden></canvas>

  </div>  <!-- JSZip CDN for .zip handling -->  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>  <script>
    const fileEl = document.getElementById('file');
    const rangeEl = document.getElementById('range');
    const valEl = document.getElementById('val');
    const startBtn = document.getElementById('start');
    const uploadMsg = document.getElementById('uploadMsg');
    const processProgress = document.getElementById('processProgress');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let filesSelected = []; // FileList normalized to Array

    const IMAGE_EXTS = ['.png','.jpg','.jpeg','.webp'];
    const isImageName = (name) => IMAGE_EXTS.some(ext => name.toLowerCase().endsWith(ext));
    const mimeFromName = (name) => {
      const n = name.toLowerCase();
      if(n.endsWith('.png')) return 'image/png';
      if(n.endsWith('.jpg')||n.endsWith('.jpeg')) return 'image/jpeg';
      if(n.endsWith('.webp')) return 'image/webp';
      return 'image/png';
    };

    // Slider background
    const applySliderBg = () => {
      const v = Number(rangeEl.value);
      rangeEl.style.background = `linear-gradient(90deg, var(--blue) ${v}%, var(--gray) ${v}%)`;
    };
    applySliderBg();

    rangeEl.addEventListener('input', () => { valEl.value = rangeEl.value; applySliderBg(); });
    valEl.addEventListener('input', () => { const c=Math.max(0,Math.min(100,Number(valEl.value||0))); valEl.value=c; rangeEl.value=c; applySliderBg(); });

    // Helper UI messages
    const fadeOutMsg = (el, delay=1200) => {
      setTimeout(()=>{ el.style.opacity = 0; }, delay);
      setTimeout(()=>{ el.textContent=''; el.style.opacity=1; }, delay+800);
    };

    // Read file input (images or a single zip)
    fileEl.addEventListener('change', () => {
      filesSelected = Array.from(fileEl.files || []);
      if (!filesSelected.length) return;

      // Upload progress animation
      uploadMsg.style.opacity = 1;
      uploadMsg.textContent = 'Please wait... 0%';
      let p = 0; const itv = setInterval(()=>{ p=Math.min(99,p+1); uploadMsg.textContent=`Please wait... ${p}%`; }, 25);

      // We don't actually upload to server; just confirm selection and show success
      setTimeout(()=>{
        clearInterval(itv);
        uploadMsg.textContent = 'Upload Successful';
        fadeOutMsg(uploadMsg, 1200);
      }, 1200);
    });

    // Core: draw with transparency factor
    function drawTransparent(img, alphaFactor){
      const w = img.naturalWidth || img.width; const h = img.naturalHeight || img.height;
      canvas.width=w; canvas.height=h; ctx.clearRect(0,0,w,h);
      ctx.globalAlpha = alphaFactor; ctx.drawImage(img,0,0,w,h); ctx.globalAlpha = 1;
    }

    function loadImageFromBlob(blob){
      return new Promise((resolve,reject)=>{
        const url = URL.createObjectURL(blob);
        const img = new Image();
        img.onload = ()=>{ URL.revokeObjectURL(url); resolve(img); };
        img.onerror = (e)=>{ URL.revokeObjectURL(url); reject(e); };
        img.src = url;
      });
    }

    async function processImageBlobKeepName(blob, name, alphaFactor){
      const img = await loadImageFromBlob(blob);
      drawTransparent(img, alphaFactor);
      const mime = mimeFromName(name);
      const outBlob = await new Promise(res => canvas.toBlob(res, mime));
      return new File([outBlob], name, { type: mime });
    }

    // Download helper
    function triggerDownload(file){
      const url = URL.createObjectURL(file);
      const a = document.createElement('a'); a.href=url; a.download=file.name; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
    }

    // START handler: process either multiple images OR one .zip
    startBtn.addEventListener('click', async () => {
      if (!filesSelected.length){
        uploadMsg.style.opacity = 1; uploadMsg.textContent = 'Pilih file dulu ya.'; fadeOutMsg(uploadMsg, 1200); return;
      }

      // Decide mode
      const onlyOne = filesSelected.length === 1;
      const first = filesSelected[0];
      const isZip = onlyOne && /\.zip$/i.test(first.name);

      // Show progress text
      processProgress.classList.remove('hidden');
      processProgress.textContent = 'Processing... 0%';

      const alphaFactor = 1 - (Number(rangeEl.value)/100);

      try{
        if (isZip){
          // ZIP mode
          const origZipName = first.name; // keep exactly
          const buf = await first.arrayBuffer();
          const zip = await JSZip.loadAsync(buf);
          const outZip = new JSZip();

          const entries = Object.keys(zip.files);
          let done = 0; const total = entries.length || 1;

          for (const path of entries){
            const entry = zip.files[path];
            if (entry.dir){ outZip.folder(path); done++; processProgress.textContent = `Processing... ${Math.round(done/total*100)}%`; continue; }
            const isImg = isImageName(path);
            const blob = await entry.async('blob');
            if (isImg){
              try{
                const processed = await processImageBlobKeepName(blob, path, alphaFactor);
                outZip.file(path, processed);
              }catch(err){
                // if fail, keep original
                outZip.file(path, blob);
              }
            } else {
              // keep non-images as-is
              outZip.file(path, blob);
            }
            done++; processProgress.textContent = `Processing... ${Math.round(done/total*100)}%`;
          }

          const outBlob = await outZip.generateAsync({type:'blob'});
          const outFile = new File([outBlob], origZipName, {type:'application/zip'});
          triggerDownload(outFile);
          processProgress.textContent = 'Processing... 100%';
        } else {
          // Multi images mode (ignore non-images)
          const imageFiles = filesSelected.filter(f => /^image\//.test(f.type) || isImageName(f.name));
          const total = imageFiles.length;
          if (!total){ processProgress.textContent = 'Tidak ada gambar untuk diproses.'; return; }
          let done = 0;
          for (const f of imageFiles){
            const blob = await f.arrayBuffer().then(b=>new Blob([b],{type:f.type||mimeFromName(f.name)}));
            try{
              const processed = await processImageBlobKeepName(blob, f.name, alphaFactor);
              triggerDownload(processed);
            }catch(err){
              // If processing fails, skip downloading or download original?
              triggerDownload(new File([blob], f.name, {type:f.type||mimeFromName(f.name)}));
            }
            done++; processProgress.textContent = `Processing... ${Math.round(done/total*100)}%`;
          }
        }
      } catch(e){
        uploadMsg.style.opacity = 1; uploadMsg.textContent = 'Terjadi kesalahan saat memproses.'; fadeOutMsg(uploadMsg, 1500);
        console.error(e);
      }
    });
  </script></body>
</html>
